# 71. Kubernetes Engineの概要

---

## Kubernetes Engineとは  
- コンテナのオーケストレーター  
- コンテナとは、アプリケーションをパッケージ化した仮想化技術の一種（例：Docker）  
- KubernetesはGoogleが社内で使っていたBorgをオープンソース化したもの  
- Kubernetes EngineはGCP上で提供されるマネージドKubernetesサービス  
- 他クラウド（AWS、Azure）にも同様のサービスがあるが、名称や一部機能は異なる  

## モードの種類  
- **スタンダードモード**  
  - ノード（VM）の管理を自分で行う  
- **オートパイロットモード**  
  - ノード管理をGoogleに委任できる  
  - Kubernetes Engine特有のモードで利便性向上  

## Kubernetesの基本概念  
- **Pod（ポッド）**  
  - コンテナの実行単位（アプリケーションパッケージ）  
- **ノード**  
  - Podを動かすVMや物理マシン  
- **Deployment（デプロイメント）**  
  - Podの配置やスケールを管理する仕組み  
- **Service（サービス）**  
  - Podへのトラフィックの流れを管理（ロードバランサー等）  

## Kubernetesの管理方法  
- `kubectl`コマンド（CLI）で管理  
- YAMLファイルで構成情報を宣言的に管理  
- GCPコンソールでも一部操作可能だが、細かい設定はコマンドやYAMLが必要  

## Kubernetesの利用価値とデメリット  
- **価値**  
  - 多数のアプリケーションを効率的に管理・オーケストレーションできる  
  - 複数インスタンスを容易に運用しリソースの無駄を削減できる  
  - 大規模なシステムやマルチクラウド・オンプレ連携にも対応可能  
- **デメリット**  
  - 学習コストが高い（概念理解やYAML記述、CLI操作が必要）  
  - 管理が複雑なため運用には経験が必要  

## 今後の動向  
- GCPコンソールのUI改善やオートパイロットモードの強化で扱いやすさ向上  
- 次のレクチャーでKubernetesの各コンポーネントの仕組みを詳細解説予定  

---
# 72. GKEのアーキテクチャ

---

## Kubernetesコンポーネントの構成

### 1. マスターノード（コントロールプレーン）
- Google（GCP）が管理するノード  
- クラスター全体の管理・制御を担当  
- 主なコンポーネント：  
  - **APIサーバー**：kubectlなどからの指示を受ける  
  - **コントロールマネージャー**：DeploymentやServiceの管理  
  - **etcd**：設定や機密情報などの保存（ボリューム管理）  
  - **スケジューラー**：Podの配置先ノードを決定  

### 2. ノード（ワーカーノード）
- 実際にPodが動作するVMや物理マシン  
- GCPの場合はCompute EngineのVMがノードとして動作  
- 複数ノードの集合体を「クラスター」と呼ぶ  
- 各ノードにはKubernetesエージェント（kubelet）が動き、スケジューラーと通信  
- Podの起動や管理を行う  

---

## Kubernetesの主要コンポーネント説明
- **Pod（ポッド）**：アプリケーション単位の実行環境（例：Webサーバーのコンテナ群）  
- **スケジューラー**：Podをどのノードに配置するか決定し、負荷分散や可用性を確保  
- **kube-proxy**：ネットワーク通信を管理し、トラフィックを各Podへ分散  
- **Service**：外部からのトラフィックをPodに適切に振り分けるロードバランサー的役割  

---

## 配置と可用性の仕組み
- Podは複数ノードに分散配置されることで、  
  - 1つのノードが障害を起こしても他ノードでサービス継続可能  
  - 負荷分散が効率的に行われる  

---

## 管理と宣言的構成
- 管理者は`kubectl`コマンドやGCPコンソール、YAMLファイルを使って構成管理  
- **宣言的管理**：  
  - 例えば「WebサーバーPodを3つ作る」とYAMLで宣言  
  - Kubernetesが自動でPodの作成・再起動を行う  
- 手続き型ではなく宣言型のため、障害時も状態を自動復元可能  

---

## GKE（Google Kubernetes Engine）におけるアーキテクチャの特徴
- マスターノード（コントロールプレーン）はGoogleが管理  
- ワーカーノードはCompute EngineのVMで構成  
- **スタンダードモード**：  
  - ノードの管理や設定を自分で行う  
  - ノード単位で料金発生（稼働中のVM分）  
- **オートパイロットモード**：  
  - ノード管理をGoogleに委任  
  - Pod単位で料金発生  
  - 利便性が高く、初心者にも扱いやすい  

---

## 今後の展望
- 次のレクチャーでYAMLファイルを使った具体的な操作を解説予定  

---
# 73. コンソールによるGKE構築

---

## GKE（Google Kubernetes Engine）をGCPコンソールから操作

- GCPコンソールの「コンピューティング」→「Kubernetes Engine」から操作  
- クラスターはノードの集まりで、ワークロード（Pod単位のアプリケーション）を管理  
- ネットワーク周りは「サービス」「Ingress」で負荷分散やトラフィック制御を行う  
- SecretやConfigMapで機密情報や環境変数を管理  
- ストレージ設定も可能  

---

## クラスターの作成方法

- **スタンダードモード**  
  - 自分でノードやスケーリング設定など細かく管理  
  - 構成が複雑でやや上級者向け  

- **オートパイロットモード**  
  - Googleにノード管理を任せられ、簡単に利用可能  
  - 課金はPod単位  
  - 初心者にも扱いやすい  

---

## オートパイロットモードでのクラスター作成の流れ

- リージョン選択（例：アジア北東1（東京））  
- ネットワーク設定やセキュリティ設定（暗号化鍵、メンテナンス自動化等）も可能だが、シンプルに済む  
- 作成に約5分程度かかる  
- スタンダードモードとは違い、Compute EngineのVMインスタンスはコンソール上に直接表示されない  

---

## アプリケーション（ワークロード）のデプロイ

- クラスター上にコンテナアプリを配置  
- 既存のDockerコンテナイメージを使うことが可能  
  - Google Container RegistryやDocker Hubなどから取得可能  
- 例：NGINXの公式コンテナイメージを選択しデプロイ  
- コンテナの環境変数設定やラベル付けもGUI上で可能  
- デプロイ完了まで約2分  

---

## トラフィックの流れの設定（サービスの作成）

- Podに直接外部IPは割り当てられないため、  
- **サービス**を作成してトラフィックをPodに流す必要がある  
- サービスのタイプには主に以下がある：  
  - **LoadBalancer（ロードバランサー）**：外部からのアクセス用  
  - **NodePort**：各ノードのポートを直接指定してアクセス  
  - **ClusterIP**：クラスタ内部のみ  

- ここではロードバランサーを使い、外部向けIPを取得して公開  
- サービス作成後、外部IPアドレスとポート（例：80番）でアクセス可能に  

---

## 動作確認

- ブラウザで外部IPにアクセスすると、NGINXのウェルカムページが表示  
- リロードすることで3つのPodにトラフィックが分散されることが確認できる  
- サービスはロードバランサーでリクエストを各Podに均等に振り分けている  

---

## まとめ

- GCPコンソールだけでクラスター作成からアプリケーションデプロイ、公開までできる  
- オートパイロットモードで簡単に利用可能  
- 今後はYAMLファイルを使ったより詳細な管理や配置も学習予定  

---
# 74. YAMLファイルによるGKE構築

---

## 概要

- 今回はGCPコンソールではなく、**YAMLファイル**を使ってKubernetesのPodやサービスを構成・デプロイする方法を解説  
- Microsoft Azureのクイックスタートから持ってきたシンプルなYAMLファイルを使用  
- アプリケーションはフロントエンド（WEB）とバックエンド（Redisデータベース）の2つのコンポーネントから構成  

---

## YAMLファイルの構成

YAMLファイルは大きく4つのパートで構成されている：

1. **バックエンドのデプロイメント**  
   - Podのレプリカ数は1  
   - コンテナイメージはMicrosoftのパブリックAzure Container Registryから取得  
   - CPU・メモリリソースや使用ポート番号も定義  
   - 環境変数でバックエンド設定を渡す  

2. **バックエンドのサービス**  
   - 内部通信向けのClusterIPタイプのサービス  
   - ポート番号設定  

3. **フロントエンドのデプロイメント**  
   - フロント側のPod設定（WEBアプリ）  
   - コンテナイメージ、リソース、環境変数定義あり  

4. **フロントエンドのサービス**  
   - ロードバランサータイプのサービス  
   - 外部からアクセス可能なIPアドレスを割り当てる  
   - ポート番号指定し、フロントエンドPodにトラフィックを流す  

---

## YAMLファイルの適用方法

- `kubectl apply -f [ファイル名]` コマンドでYAMLファイルをクラスタに適用  
- GCPのクラウドシェルからも実行可能  
- `kubectl config` の設定に注意（対象クラスターへの接続設定）  
- 正しく設定されていない場合はconfig修正が必要  

---

## デプロイの様子

- コマンド実行後、4つのコンポーネント（2デプロイメント、2サービス）がクラスタ上に作成される  
- ワークロード画面でPodの状態を確認可能  
- サービスのロードバランサータイプは外部IPを取得し、Webアプリへのアクセスが可能になる  
- 起動には少し時間がかかるが、正常に動作すればWeb画面が表示される  

---

## Kubernetesの特性と操作例

- Podを手動で削除しても、YAMLファイルの宣言に基づきKubernetesが自動的に再作成し復元する  
- YAMLのレプリカ数を変更するとPod数も自動的に増減し、クラスタ状態が更新される  
- Kubernetesは宣言的な管理を行うため、YAMLで定義した通りにリソース状態を保つ  
- UIからは細かいPodの動きが見えづらいこともある  

---

## 注意点・学び

- `kubectl` のconfigファイルやクラスター設定を理解し、適切に管理する必要がある  
- Kubernetesの便利さの反面、操作や設定には一定の学習コストがある  
- YAMLファイルによる宣言的構成は、GKEなどのKubernetes環境で効率的な運用を実現する重要な手法  

---
